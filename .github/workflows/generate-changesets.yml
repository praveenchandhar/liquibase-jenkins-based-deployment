name: Generate Changesets (Manual Jenkins Deployment)

on:
  pull_request:
    paths:
      - db/mongodb/dev/weekly_release/**
      - db/mongodb/dev/monthly_release/**
    types:
      - opened
      - synchronize

jobs:
  generate-changesets:
    name: Generate Changesets for Manual Deployment
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write

    steps:
      # Step 1: Checkout Repository
      - name: Checkout Repository
        uses: actions/checkout@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      # Step 2: Debug PR Information
      - name: Debug PR Information
        run: |
          echo "=== PR Debug Information ==="
          echo "PR Number: ${{ github.event.pull_request.number }}"
          echo "PR Title: ${{ github.event.pull_request.title }}"
          echo "Base Branch: ${{ github.event.pull_request.base.ref }}"
          echo "Head Branch: ${{ github.event.pull_request.head.ref }}"

      # Step 3: Detect JS Files in PR
      - name: Detect JS Files in PR
        id: detect_js_files
        run: |
          echo "=== JS File Detection in PR ==="
          
          HEAD_SHA="${{ github.event.pull_request.head.sha }}"
          BASE_SHA="${{ github.event.pull_request.base.sha }}"
          
          # Get changed files in the PR
          CHANGED_FILES=$(git diff --name-only $BASE_SHA..$HEAD_SHA 2>/dev/null || echo "")
          
          # Filter for JS files in our target directories
          JS_FILES=$(echo "$CHANGED_FILES" | grep -E 'db/mongodb/dev/(weekly_release|monthly_release)/[0-9]{8}/.*\.js$' || true)
          
          if [ -z "$JS_FILES" ]; then
            echo "‚ùå No .js files found in target directories"
            echo "has_js_files=false" >> $GITHUB_ENV
          else
            echo "‚úÖ JS files detected:"
            echo "$JS_FILES"
            echo "js_files=$JS_FILES" >> $GITHUB_ENV
            echo "has_js_files=true" >> $GITHUB_ENV
            
            FILE_COUNT=$(echo "$JS_FILES" | wc -l)
            echo "file_count=$FILE_COUNT" >> $GITHUB_ENV
          fi

      # Step 4: Setup Python Environment
      - name: Setup Python Environment
        if: env.has_js_files == 'true'
        run: |
          python3 --version
          pip3 install PyGithub requests pyyaml

      # Step 5: Process JS Files and Generate XML
      - name: Process JS Files and Generate XML
        if: env.has_js_files == 'true'
        run: |
          echo "=== Processing JS Files and Generating XML ==="
          
          PROCESSED_FILES=0
          SUCCESSFUL_FILES=0
          GENERATED_XML_FILES=""
          
          while IFS= read -r js_file; do
            if [ -n "$js_file" ] && [ -f "$js_file" ]; then
              PROCESSED_FILES=$((PROCESSED_FILES + 1))
              echo "üîÑ Processing: $js_file"
              
              # Extract date and create version
              JS_DIR=$(dirname "$js_file")
              JS_FILENAME=$(basename "$js_file" .js)
              DATE_PATTERN=$(echo "$JS_DIR" | grep -oE '[0-9]{8}' | head -1)
              
              if [ -z "$DATE_PATTERN" ]; then
                echo "‚ùå Could not extract date from: $JS_DIR"
                continue
              fi
              
              EXISTING_JS_COUNT=$(find "$JS_DIR" -name "*.js" | wc -l)
              VERSION="${DATE_PATTERN}_${EXISTING_JS_COUNT}"
              XML_FILE="${JS_DIR}/${JS_FILENAME}.xml"
              
              # Execute Python script
              python3 scripts/v4.py \
                --version "$VERSION" \
                --js_file "$js_file" \
                --author "${{ github.actor }}" \
                --repo "${{ github.repository }}" \
                --branch "${{ github.event.pull_request.head.ref }}" \
                --token "${{ secrets.GITHUB_TOKEN }}" \
                --no-pr
              
              if [ -f "$XML_FILE" ]; then
                echo "‚úÖ XML generated: $XML_FILE"
                SUCCESSFUL_FILES=$((SUCCESSFUL_FILES + 1))
                GENERATED_XML_FILES="$GENERATED_XML_FILES$XML_FILE"$'\n'
              fi
            fi
          done <<< "${{ env.js_files }}"
          
          echo "processed_files=$PROCESSED_FILES" >> $GITHUB_ENV
          echo "successful_files=$SUCCESSFUL_FILES" >> $GITHUB_ENV
          echo "generated_xml_files=$GENERATED_XML_FILES" >> $GITHUB_ENV

      # Step 6: Commit XML Files to PR Branch
      - name: Commit XML Files to PR Branch
        if: env.has_js_files == 'true' && env.successful_files > 0
        run: |
          echo "=== Committing XML Files to PR Branch ==="
          
          git config --local user.email "praveenchandhar1974@gmail.com"
          git config --local user.name "praveen.chandhar"
          
          while IFS= read -r xml_file; do
            if [ -n "$xml_file" ] && [ -f "$xml_file" ]; then
              git add "$xml_file"
            fi
          done <<< "${{ env.generated_xml_files }}"
          
          if ! git diff --staged --quiet; then
            COMMIT_MSG="ü§ñ Auto-generated XML changesets for ${{ github.event.pull_request.title }}"
            git commit -m "$COMMIT_MSG"
            git push origin HEAD:${{ github.event.pull_request.head.ref }}
            echo "‚úÖ XML files committed to PR branch"
          fi

      # Step 7: Extract Database Context from XML
      - name: Extract Database Context
        if: env.has_js_files == 'true' && env.successful_files > 0
        run: |
          echo "=== Extracting Database Context ==="
          
          FIRST_XML=$(echo "${{ env.generated_xml_files }}" | head -n 1)
          if [ -f "$FIRST_XML" ]; then
            # Use sed instead of grep -P for better compatibility
            CONTEXT=$(sed -n 's/.*context="\([^"]*\)".*/\1/p' "$FIRST_XML" | head -n 1)
            if [ -z "$CONTEXT" ]; then
              CONTEXT="liquibase_test"
            fi
            echo "context=$CONTEXT" >> $GITHUB_ENV
            echo "‚úÖ Database context: $CONTEXT"
          else
            echo "context=liquibase_test" >> $GITHUB_ENV
          fi

      # Step 8: Post Manual Jenkins Instructions
      - name: Post Manual Jenkins Instructions
        if: env.has_js_files == 'true' && env.successful_files > 0
        uses: actions/github-script@v6
        with:
          script: |
            const branchName = '${{ github.event.pull_request.head.ref }}';
            const dbContext = '${{ env.context }}';
            const processedFiles = '${{ env.successful_files }}';
            const jenkinsUrl = 'http://localhost:8080';
            
            const commentBody = `## ü§ñ XML Changesets Generated - Ready for Manual Jenkins Deployment

            **Branch:** \`${branchName}\`  
            **Database Context:** \`${dbContext}\`  
            **Files Processed:** ${processedFiles} changeset(s)  

            ## üìã Manual Jenkins Deployment Steps

            ### 1. Go to Jenkins Dashboard
            üåê **Jenkins URL:** [${jenkinsUrl}](${jenkinsUrl})

            ### 2. Navigate to the Deployment Job
            üìÅ **Job Name:** \`liquibase-mongo-jenkins-deployment\`  
            üîó **Direct Link:** [${jenkinsUrl}/job/liquibase-mongo-jenkins-deployment](${jenkinsUrl}/job/liquibase-mongo-jenkins-deployment)

            ### 3. Click "Build with Parameters"
            üìã **Enter these parameters:**
            - **BRANCH_OR_TAG:** \`${branchName}\`
            - **LIQUIBASE_ACTION:** \`update\` (for deployment) or \`status\` (for dry-run)
            - **ROLLBACK_COUNT:** \`1\` (not used for update/status)

            ### 4. Click "Build" to Start Manual Deployment

            ### 5. After Jenkins Deployment
            - ‚úÖ **If Jenkins succeeds:** Manually merge this PR
            - ‚ùå **If Jenkins fails:** Check logs, fix issues, and re-run Jenkins

            ## üìä Deployment Details
            - **Branch to Deploy:** \`${branchName}\`
            - **Database Context:** \`${dbContext}\` (auto-detected from XML)
            - **Changesets Ready:** ${processedFiles} file(s)

            ## ‚ö†Ô∏è Important Notes
            - **DO NOT MERGE** this PR until Jenkins deployment succeeds
            - Test with \`status\` action first, then use \`update\` to apply changes
            - If deployment fails, you can push more commits to fix issues

            ---
            *ü§ñ Automated XML generation completed*  
            *‚ö° [View Workflow Run](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})*
            `;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              body: commentBody
            });

      # Step 9: Summary
      - name: Workflow Summary
        if: always()
        run: |
          echo "=== XML Generation Summary ==="
          echo "PR: ${{ github.event.pull_request.title }}"
          echo "Branch: ${{ github.event.pull_request.head.ref }}"
          echo "JS Files: ${{ env.has_js_files }}"
          echo "Processed: ${{ env.processed_files }}"
          echo "Successful: ${{ env.successful_files }}"
          echo "Context: ${{ env.context }}"
          echo ""
          if [ "${{ env.has_js_files }}" = "true" ]; then
            echo "‚úÖ XML changesets generated - Ready for manual Jenkins deployment"
          else
            echo "‚ÑπÔ∏è No JS files to process"
          fi
