name: Generate Changesets and Deploy via Jenkins

on:
  pull_request:
    paths:
      - db/mongodb/dev/weekly_release/**
      - db/mongodb/dev/monthly_release/**
    types:
      - opened
      - synchronize

jobs:
  generate-and-deploy:
    name: Generate Changesets and Deploy
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write

    steps:
      # Step 1: Checkout Repository
      - name: Checkout Repository
        uses: actions/checkout@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      # Step 2: Debug PR Information
      - name: Debug PR Information
        run: |
          echo "=== PR Debug Information ==="
          echo "PR Number: ${{ github.event.pull_request.number }}"
          echo "PR Title: ${{ github.event.pull_request.title }}"
          echo "Base Branch: ${{ github.event.pull_request.base.ref }}"
          echo "Head Branch: ${{ github.event.pull_request.head.ref }}"

      # Step 3: Detect JS Files in PR
      - name: Detect JS Files in PR
        id: detect_js_files
        run: |
          echo "=== JS File Detection in PR ==="
          
          HEAD_SHA="${{ github.event.pull_request.head.sha }}"
          BASE_SHA="${{ github.event.pull_request.base.sha }}"
          
          # Get changed files in the PR
          CHANGED_FILES=$(git diff --name-only $BASE_SHA..$HEAD_SHA 2>/dev/null || echo "")
          
          # Filter for JS files in our target directories
          JS_FILES=$(echo "$CHANGED_FILES" | grep -E 'db/mongodb/dev/(weekly_release|monthly_release)/[0-9]{8}/.*\.js$' || true)
          
          if [ -z "$JS_FILES" ]; then
            echo "‚ùå No .js files found in target directories"
            echo "has_js_files=false" >> $GITHUB_ENV
          else
            echo "‚úÖ JS files detected:"
            echo "$JS_FILES"
            echo "js_files=$JS_FILES" >> $GITHUB_ENV
            echo "has_js_files=true" >> $GITHUB_ENV
            
            FILE_COUNT=$(echo "$JS_FILES" | wc -l)
            echo "file_count=$FILE_COUNT" >> $GITHUB_ENV
          fi

      # Step 4: Setup Python Environment
      - name: Setup Python Environment
        if: env.has_js_files == 'true'
        run: |
          python3 --version
          pip3 install PyGithub requests pyyaml

      # Step 5: Process JS Files and Generate XML
      - name: Process JS Files and Generate XML
        if: env.has_js_files == 'true'
        run: |
          echo "=== Processing JS Files and Generating XML ==="
          
          PROCESSED_FILES=0
          SUCCESSFUL_FILES=0
          GENERATED_XML_FILES=""
          
          while IFS= read -r js_file; do
            if [ -n "$js_file" ] && [ -f "$js_file" ]; then
              PROCESSED_FILES=$((PROCESSED_FILES + 1))
              echo "üîÑ Processing: $js_file"
              
              # Extract date and create version
              JS_DIR=$(dirname "$js_file")
              JS_FILENAME=$(basename "$js_file" .js)
              DATE_PATTERN=$(echo "$JS_DIR" | grep -oE '[0-9]{8}' | head -1)
              
              if [ -z "$DATE_PATTERN" ]; then
                echo "‚ùå Could not extract date from: $JS_DIR"
                continue
              fi
              
              EXISTING_JS_COUNT=$(find "$JS_DIR" -name "*.js" | wc -l)
              VERSION="${DATE_PATTERN}_${EXISTING_JS_COUNT}"
              XML_FILE="${JS_DIR}/${JS_FILENAME}.xml"
              
              # Execute Python script
              python3 scripts/v4.py \
                --version "$VERSION" \
                --js_file "$js_file" \
                --author "${{ github.actor }}" \
                --repo "${{ github.repository }}" \
                --branch "${{ github.event.pull_request.head.ref }}" \
                --token "${{ secrets.GITHUB_TOKEN }}" \
                --no-pr
              
              if [ -f "$XML_FILE" ]; then
                echo "‚úÖ XML generated: $XML_FILE"
                SUCCESSFUL_FILES=$((SUCCESSFUL_FILES + 1))
                GENERATED_XML_FILES="$GENERATED_XML_FILES$XML_FILE"$'\n'
              fi
            fi
          done <<< "${{ env.js_files }}"
          
          echo "processed_files=$PROCESSED_FILES" >> $GITHUB_ENV
          echo "successful_files=$SUCCESSFUL_FILES" >> $GITHUB_ENV
          echo "generated_xml_files=$GENERATED_XML_FILES" >> $GITHUB_ENV

      # Step 6: Commit XML Files to PR Branch
      - name: Commit XML Files to PR Branch
        if: env.has_js_files == 'true' && env.successful_files > 0
        run: |
          echo "=== Committing XML Files to PR Branch ==="
          
          git config --local user.email "praveenchandhar1974@gmail.com"
          git config --local user.name "praveen.chandhar"
          
          while IFS= read -r xml_file; do
            if [ -n "$xml_file" ] && [ -f "$xml_file" ]; then
              git add "$xml_file"
            fi
          done <<< "${{ env.generated_xml_files }}"
          
          if ! git diff --staged --quiet; then
            COMMIT_MSG="ü§ñ Auto-generated XML changesets for ${{ github.event.pull_request.title }}"
            git commit -m "$COMMIT_MSG"
            git push origin HEAD:${{ github.event.pull_request.head.ref }}
            echo "‚úÖ XML files committed to PR branch"
          fi

      # Step 7: Extract Database Context from XML
      - name: Extract Database Context
        if: env.has_js_files == 'true' && env.successful_files > 0
        run: |
          echo "=== Extracting Database Context ==="
          
          FIRST_XML=$(echo "${{ env.generated_xml_files }}" | head -n 1)
          if [ -f "$FIRST_XML" ]; then
            # Use sed instead of grep -P for better compatibility
            CONTEXT=$(sed -n 's/.*context="\([^"]*\)".*/\1/p' "$FIRST_XML" | head -n 1)
            if [ -z "$CONTEXT" ]; then
              CONTEXT="liquibase_test"
            fi
            echo "context=$CONTEXT" >> $GITHUB_ENV
            echo "‚úÖ Database context: $CONTEXT"
          else
            echo "context=liquibase_test" >> $GITHUB_ENV
          fi

      # Step 8: Trigger Jenkins Deployment
      - name: Trigger Jenkins Deployment
        if: env.has_js_files == 'true' && env.successful_files > 0
        id: jenkins_deploy
        run: |
          echo "=== Triggering Jenkins Deployment ==="
          
          JENKINS_URL="${{ secrets.JENKINS_URL || 'http://localhost:8080' }}"
          JENKINS_USER="${{ secrets.JENKINS_USER }}"
          JENKINS_TOKEN="${{ secrets.JENKINS_TOKEN }}"
          JOB_NAME="liquibase-mongo-jenkins-deployment"
          BRANCH_NAME="${{ github.event.pull_request.head.ref }}"
          
          echo "üöÄ Triggering Jenkins deployment..."
          echo "   Branch: $BRANCH_NAME"
          echo "   Context: ${{ env.context }}"
          echo "   Jenkins URL: $JENKINS_URL"
          
          if [ -n "$JENKINS_USER" ] && [ -n "$JENKINS_TOKEN" ]; then
            # Trigger Jenkins job
            JENKINS_RESPONSE=$(curl -s -w "%{http_code}" \
              -X POST \
              -u "$JENKINS_USER:$JENKINS_TOKEN" \
              "$JENKINS_URL/job/$JOB_NAME/buildWithParameters" \
              -d "BRANCH_OR_TAG=$BRANCH_NAME" \
              -d "LIQUIBASE_ACTION=update" \
              -d "ROLLBACK_COUNT=1")
            
            HTTP_CODE="${JENKINS_RESPONSE: -3}"
            
            if [ "$HTTP_CODE" = "201" ] || [ "$HTTP_CODE" = "200" ]; then
              echo "‚úÖ Jenkins job triggered successfully"
              echo "jenkins_triggered=true" >> $GITHUB_ENV
              
              # Wait for job to complete
              echo "‚è≥ Waiting for Jenkins job to complete..."
              sleep 30  # Give Jenkins time to start
              
              # Check job status (simplified - you might want to make this more robust)
              for i in {1..10}; do
                echo "üîç Checking job status (attempt $i/10)..."
                
                JOB_STATUS=$(curl -s \
                  -u "$JENKINS_USER:$JENKINS_TOKEN" \
                  "$JENKINS_URL/job/$JOB_NAME/lastBuild/api/json" | \
                  grep -o '"result":"[^"]*"' | cut -d':' -f2 | tr -d '"')
                
                if [ "$JOB_STATUS" = "SUCCESS" ]; then
                  echo "‚úÖ Jenkins deployment successful!"
                  echo "jenkins_success=true" >> $GITHUB_ENV
                  break
                elif [ "$JOB_STATUS" = "FAILURE" ]; then
                  echo "‚ùå Jenkins deployment failed!"
                  echo "jenkins_success=false" >> $GITHUB_ENV
                  break
                elif [ "$JOB_STATUS" = "null" ] || [ -z "$JOB_STATUS" ]; then
                  echo "‚è≥ Job still running... waiting 30 seconds"
                  sleep 30
                else
                  echo "üîÑ Job status: $JOB_STATUS"
                  sleep 30
                fi
              done
              
              if [ "${{ env.jenkins_success }}" != "true" ]; then
                echo "‚è∞ Job timeout or failed"
                echo "jenkins_success=false" >> $GITHUB_ENV
              fi
              
            else
              echo "‚ùå Failed to trigger Jenkins job (HTTP: $HTTP_CODE)"
              echo "jenkins_triggered=false" >> $GITHUB_ENV
            fi
          else
            echo "‚ö†Ô∏è Jenkins credentials not configured"
            echo "jenkins_triggered=false" >> $GITHUB_ENV
          fi

      # Step 9: Auto-merge PR if Jenkins deployment successful
      - name: Auto-merge PR on Successful Deployment
        if: env.jenkins_success == 'true'
        uses: actions/github-script@v6
        with:
          script: |
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number
            });
            
            if (pr.mergeable) {
              await github.rest.pulls.merge({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.payload.pull_request.number,
                commit_title: `üöÄ Auto-merge after successful deployment: ${pr.title}`,
                commit_message: `Automatically merged after successful Jenkins deployment to database.\n\nDeployment details:\n- Branch: ${{ github.event.pull_request.head.ref }}\n- Context: ${{ env.context }}\n- Files processed: ${{ env.successful_files }}`,
                merge_method: "squash"
              });
              
              console.log('‚úÖ PR auto-merged after successful deployment');
            } else {
              console.log('‚ùå PR not mergeable');
            }

      # Step 10: Post deployment status comment
      - name: Post Deployment Status
        if: env.has_js_files == 'true' && env.successful_files > 0
        uses: actions/github-script@v6
        with:
          script: |
            const jenkinsSuccess = '${{ env.jenkins_success }}';
            const branchName = '${{ github.event.pull_request.head.ref }}';
            const dbContext = '${{ env.context }}';
            const processedFiles = '${{ env.successful_files }}';
            const jenkinsUrl = '${{ secrets.JENKINS_URL || 'http://localhost:8080' }}';
            
            let statusIcon, statusText, nextSteps;
            
            if (jenkinsSuccess === 'true') {
              statusIcon = '‚úÖ';
              statusText = 'DEPLOYMENT SUCCESSFUL';
              nextSteps = `
              ## üéâ Deployment Completed Successfully!
              
              Your changes have been successfully deployed to the database and the PR has been auto-merged.
              
              **What happened:**
              1. ‚úÖ XML changesets generated from JS files
              2. ‚úÖ Jenkins deployment executed successfully  
              3. ‚úÖ Database changes applied
              4. ‚úÖ PR automatically merged
              `;
            } else {
              statusIcon = '‚ùå';
              statusText = 'DEPLOYMENT FAILED';
              nextSteps = `
              ## üö® Deployment Failed
              
              The Jenkins deployment failed. Please check the logs and fix any issues.
              
              **Next steps:**
              1. üîç Check Jenkins logs: [${jenkinsUrl}/job/liquibase-mongo-jenkins-deployment](${jenkinsUrl}/job/liquibase-mongo-jenkins-deployment)
              2. üîß Fix any issues in your changeset files
              3. üîÑ Push additional commits to trigger re-deployment
              4. üìù PR will remain open until deployment succeeds
              `;
            }
            
            const commentBody = `## ${statusIcon} Database Deployment Status: ${statusText}
            
            **Branch:** \`${branchName}\`  
            **Database Context:** \`${dbContext}\`  
            **Files Processed:** ${processedFiles} changeset(s)  
            **Jenkins Job:** [View Details](${jenkinsUrl}/job/liquibase-mongo-jenkins-deployment)
            
            ${nextSteps}
            
            ---
            *ü§ñ Automated deployment via Jenkins*  
            *‚ö° [View Workflow Run](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})*
            `;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              body: commentBody
            });

      # Step 11: Summary
      - name: Workflow Summary
        if: always()
        run: |
          echo "=== Deployment Workflow Summary ==="
          echo "PR: ${{ github.event.pull_request.title }}"
          echo "Branch: ${{ github.event.pull_request.head.ref }}"
          echo "JS Files: ${{ env.has_js_files }}"
          echo "Processed: ${{ env.processed_files }}"
          echo "Successful: ${{ env.successful_files }}"
          echo "Jenkins Triggered: ${{ env.jenkins_triggered }}"
          echo "Jenkins Success: ${{ env.jenkins_success }}"
          
          if [ "${{ env.jenkins_success }}" = "true" ]; then
            echo "üéâ Deployment successful - PR auto-merged"
            exit 0
          elif [ "${{ env.has_js_files }}" = "true" ]; then
            echo "‚ùå Deployment failed - PR remains open"
            exit 1
          else
            echo "‚ÑπÔ∏è No JS files to process"
            exit 0
          fi
